
---
## Инициализация нового репозитория
#git #init #initialization #инициализация
```bash
git init
```
P.S. можно начать делать всё локально, а привязать репозиторий уже позже

---
## Связка локального и удалённого репозитория
#git #remote #origin #связь #связка
```bash
# привязка
git remote add origin https://github.com/username/repository.git
# проверка, какие удаленные репо связаны с вашим локальным репо
git remote -v
# отправка коммитов в удаленный репо
git push -u origin main
```

---
## Создание пустого коммита
#commit #empty #пустой 
```bash
git --allow-empty -m "empty commit"
```
P.S. так можно запустить CI, если он настроен на push в определенную ветку

---

## Бинарный поиск
#bisect #binary_search #git

>P.S. интересные команды, но на практике ни разу не пользовался :)

команда bisect позволяет нам легко откатить проект на заданное число коммитов и найти тот коммит, в котором неуловимый баг проявляется в первый раз.  
  
Во-первых, запускаем механизм поиска и устанавливаем значение, что текущее состояние проекта нерабочее  
  
```bash
git bisect start  
git bisect bad 
```  
  
Далее откатываемся на рабочее состояние проекта — на 10 коммитов назад по истории  
  
```bash
git bisect good HEAD~10
```  
  
Смотрим, проявляется ли этот баг в текущем состоянии. Допустим, сейчас с проектом все хорошо, поэтому продолжаем поиск дальше  
  
```bash
git bisect good
```  
  
Эта команда перематывает состояние проекта в середину, между хорошим коммитом и плохим, т. е. Сейчас мы находимся в пяти коммитах назад по истории. Если баг проявляется, то он находится до текущего коммита, если нет — то после. С каждой такой итерацией расстояние уменьшается в два раза, пока мы не находим плохой коммит (а главное — его автора, к сожалению, это его опять сделали мы).  
  
После завершения поиска сбрасываем репозиторий в исходное состояние  
  
```bash
git bisect reset
```

Реальный пример:
```bash
git bisect start
git bisect bad HEAD
status: waiting for good commit(s), bad commit known
git bisect good fd874ff7657fc9373176c39e57975a842f308e1a
Бинарный поиск: 9 редакций осталось проверить после этой (примерно 3 шага)
[c6f1c752dbc3ec445ac6cbc66bbe827478d8394b] SK-15464 - название коммита k...
git bisect bad
Бинарный поиск: 5 редакций осталось проверить после этой (примерно 2 шага)
[24ead05be46a1ecc21c14fa500ce1c2a3ff6ece7] Merge branch 'feature/SK-15452' into 'develop'
git bisect good
Бинарный поиск: 2 редакции осталось проверить после этой (примерно 2 шага)
[b04b2fb990bb724f7c36e2c2e7c111a98a040425] SK-15421 - название коммита n...
git bisect good
Бинарный поиск: 0 редакций осталось проверить после этой (примерно 1 шаг)
[752bcf4cc35f0cf8191b628dc4ab1da15d3f0cdc] SK-15442 - название коммита m...
git bisect good
c6f1c752dbc3ec445ac6cbc66bbe827478d8394b is the first bad commit
commit c6f1c752dbc3ec445ac6cbc66bbe827478d8394b
Author: Victor Shulpov <shulpov.v@soft-logic.ru>
Date:   Mon Sep 22 07:56:34 2025 +0000

...- название коммита 
изменные файлы и кол-во изменений...
```

---
## git blame
#blame

git blame позволяет посмотреть когда и кем редактировалась каждая строка файла в последний раз.

```bash
git blame -L 12,22 products.php
```

результат:
```bash
ebf9cf99 (vasia 2011-11-16 15:07:52 +0400 260)$templates = $controller->getTemplates();
ebf9cf99 (vasia 2011-11-16 15:07:52 +0400 261)     foreach($templates as $value)
```

>P.S. в IDE уже всё красиво подсвечивается, не знаю зачем мне эта команда, просто интересно, что под капотом

---
## git cherry-pick
#cherry #pick #cherry-pick 
Команда `git cherry-pick` берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке. Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесёнными в неё изменениями.

P.S. хэш у коммита создается новый, время проставляется то, в которое делается cherry-pick

---

