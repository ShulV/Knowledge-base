
---
## Инициализация нового репозитория
#git #init #initialization #инициализация
```bash
git init
```
P.S. можно начать делать всё локально, а привязать репозиторий уже позже

---
## Связка локального и удалённого репозитория
#git #remote #origin #связь #связка
```bash
# привязка
git remote add origin https://github.com/username/repository.git
# проверка, какие удаленные репо связаны с вашим локальным репо
git remote -v
# отправка коммитов в удаленный репо
git push -u origin main
```

---
## Создание пустого коммита
#commit #empty #пустой 
```bash
git --allow-empty -m "empty commit"
```
P.S. так можно запустить CI, если он настроен на push в определенную ветку

---

## Бинарный поиск
#bisect #binary_search #git

>P.S. интересные команды, но на практике ни разу не пользовался :)

команда bisect позволяет нам легко откатить проект на заданное число коммитов и найти тот коммит, в котором неуловимый баг проявляется в первый раз.  
  
Во-первых, запускаем механизм поиска и устанавливаем значение, что текущее состояние проекта нерабочее  
  
```bash
git bisect start  
git bisect bad 
```  
  
Далее откатываемся на рабочее состояние проекта — на 10 коммитов назад по истории  
  
```bash
git bisect good HEAD~10
```  
  
Смотрим, проявляется ли этот баг в текущем состоянии. Допустим, сейчас с проектом все хорошо, поэтому продолжаем поиск дальше  
  
```bash
git bisect good
```  
  
Эта команда перематывает состояние проекта в середину, между хорошим коммитом и плохим, т. е. Сейчас мы находимся в пяти коммитах назад по истории. Если баг проявляется, то он находится до текущего коммита, если нет — то после. С каждой такой итерацией расстояние уменьшается в два раза, пока мы не находим плохой коммит (а главное — его автора, к сожалению, это его опять сделали мы).  
  
После завершения поиска сбрасываем репозиторий в исходное состояние  
  
```bash
git bisect reset
```

---
## git blame
#blame

git blame позволяет посмотреть когда и кем редактировалась каждая строка файла в последний раз.

```bash
git blame -L 12,22 products.php
```

результат:
```bash
ebf9cf99 (vasia 2011-11-16 15:07:52 +0400 260)$templates = $controller->getTemplates();
ebf9cf99 (vasia 2011-11-16 15:07:52 +0400 261)     foreach($templates as $value)
```

>P.S. в IDE уже всё красиво подсвечивается, не знаю зачем мне эта команда, просто интересно, что под капотом

---
## git cherry-pick
#cherry #pick #cherry-pick 
Команда `git cherry-pick` берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке. Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесёнными в неё изменениями.

P.S. хэш у коммита создается новый, время проставляется то, в которое делается cherry-pick

---

