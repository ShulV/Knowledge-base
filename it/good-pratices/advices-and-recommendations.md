
---
## Использование нового механизма технологии

обычно нужно раза 2-3 применить, чтобы более менее уверенно писать, не спрашивая "правильно ли я делаю"
примеры: 
- создание managed beans и страницы для них на primefaces
- jms listener, очереди
- флоу обычных контроллеров с запросом по цепочке сервисов
- ...

>P.S. думаю, норма, что юзать что-то впервые страшно без предводительства, нужен просто опыт. И структурно нужно привыкнуть, где их в проекте создают ту или иную функциональность, по какому код-стайлу (все равно есть какой-то общий подход).

---

## Вопросы, на которые нужно себе отвечать при код-ревью
#review #code #check #марк_симан #код_который_помещается_в_голове

- Работает ли код как задумано?
- Понятно ли намерение?
- Есть ли ненужное дублирование?
- Может ли существующий код решить эту проблему?
- Может ли код быть проще?
- Все ли тесты исчерпывающие и понятные?

Придирки бесполезны, нет смысла придираться к форматированию или к именам переменных. (это всегда может исправить позже, это не должно затягивать ревью)

---

## За чем нужно следить в проекте?
#version #legacy #dependency

- **Нужно периодически обновлять зависимости**. Чем чаще, тем проще их обновлять. Если этого не делать, переход на новую версию может стать невозможным из-за больших изменений в той или иной библиотеке (не всегда есть идеальная совместимость). Со старыми библиотеками никто не любит работать -> тяжелее нанимать людей.
- **Следить за истечением сертификатов** X.509. Они, конечно, живут месяцы/годы, но будет неприятно, если внезапно сервис "отвалится".
- **Следить за истечением доменных имён**

---

## Не откладывать критичные задачи
#марк_симан #код_который_помещается_в_голове #task 

> Большая вероятность, что отложенная задача будет сделана некорректно, т.к. контекст забудется.

> Часто те задачи, которые откладываются, не выполнятся никогда.

> Та, задача, на которую сейчас нет времени, не выполнится.  Времени не будет никогда.

P.S. мой коммент: хотя тут вопрос, если важность отложенной/забытой задачи возрастёт, наверное, всё-таки она будет выполнена. Тут довольно-таки такой вопрос, требующий искусства инженерии. Нужно в первую очередь осознавать, насколько важно сделать ту или иную задачу сразу (особенно, если это правки или рефакторинг). Можно вырастить плохую кодовую базу.

---

## Время, в котором писать логи

> Думаю, логи писать лучше в настоящем времени, т.к. там и так указана дата и время. И слова в настоящем времени обычно короче.

нравится
```
03-10-2024 05:59:37.495 Cannot get...
```

не нравится
```
03-10-2024 05:59:37.495 Could not get...
```

---

## Возвращение ответа 200 и кастомным 400 внутри тела ответа
#ok #reponse #status #code #status_code #http

P.S. плохая практика, многие клиентские/фронтовые фреймворки завязаны на дефолтный статус самого запроса, но никак не завязаны на тело.


```
URL запроса: http://localhost:8080/some-request
Метод запроса: PATCH
Код статуса: 200 OK
```

```javascript
{
    "result": {
        "code": 400,
        "message": "Функционал сохранения карт не доступен"
    },
    "data": null
}
```

---


## Выбор портов для приложений
#port #devops 
P.S.  ответ ИИ! Но мне понравилось
##### Основной бэкенд (API):
- **Порт:** 5000 или 8000
- **Причины:** Эти порты широко используются для внутренних сервисов и бэкендов. Они достаточно высоки, чтобы минимизировать конфликты с системными службами, и удобны для разработчиков.
##### Фронтенд:
- **Порт:** 3000 или 4200
- **Причины:** Порт 3000 часто используется для React приложений, а 4200 — для Angular. Оба порта популярны среди фронтенд-разработчиков и хорошо поддерживаются соответствующими инструментами сборки и запуска.
##### Микросервисы:
- **Порты:** 4000–4999
- **Причины:** Диапазон портов выше 4000 часто зарезервирован для различных внутренних сервисов и микросервисов. Использование разных портов в этом диапазоне поможет избежать конфликтов и упростит управление множеством сервисов.

#####  Keycloak:
- **Порт:** 8080
- **Причины:** Keycloak по умолчанию поднимается на порту 8080. Это стандартное решение, и изменение порта может потребовать дополнительных настроек. Оставлять его на 8080 удобно, особенно если Keycloak используется отдельно от основного приложения.
#####  Примеры
- **Основной бэкенд:** `http://localhost:5000`
- **Фронтенд:** `http://localhost:3000`
- **Микросервис 1:** `http://localhost:4000`
- **Микросервис 2:** `http://localhost:4100`
- **Keycloak:** `http://localhost:8080`

#####  Важные моменты:
1. **Безопасность:** Используйте HTTPS для всех внешних соединений, особенно для Keycloak и любых публичных интерфейсов.
2. **Реверс-прокси:** Рассмотрите использование реверс-прокси (например, Nginx) для маршрутизации запросов к различным компонентам приложения.
---

## большое количество аннотаций OpenAPI в контроллерах?
#open-api #swagger
если вы ставите слишком много аннотаций на методы вашего REST эндпоинта ради документации (характерно для OpenAPI), вы могли бы подумать о том, чтобы извлечь интерфейс и переместить все REST аннотации в него. Затем сервис приложения реализует этот интерфейс и возьмет на себя метаданные.

P.S. Swagger аннотации @Inherited

---

